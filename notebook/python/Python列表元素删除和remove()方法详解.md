删除列表中元素的方法有三种：

**1. del命令**

使用del命令能够删除列表中指定位置上的元素，也可以删除整个列表。

**2. pop( )方法**

使用列表的pop()方法能够删除并返回列表指定位置（默认为最后一个位置）的元素。

**3. remove方法**

使用列表的remove()方法能够删除列表中首次出现的指定元素，如果列表中不存在该元素则抛出异常。有的时候可能需要  **删除列表中某一大量重复的数据**
，我们很容易就会想到列表的remove()方法，例如：

```python

    x=[1,2,1,2,1,2,1,2]
    y=[1,1,2,1,2,1,2,1,1,1,2]
    for i in x:
     if i==1:
      x.remove(i)
    print("List_1=",x)
    for i in y:
     if i==1:
      y.remove(i)
    print("List_2=",y)
    
```

结果：

> List_1= [2, 2, 2, 2]  
>  
>  List_2= [2, 2, 2, 1, 1, 2]

但是当我们在具体实现时很可能会遇到意想不到的错误，代码有的时候能够达到预期的删除所有重复元素的效果，有的时候只能删除部分重复元素，如上例所示。比较两个列表，发现，列表x中
**所有的1都是不相邻** 的，列表y中  **有的1是相邻** 的。出现以上问题的原因在于，
**列表的内存自动管理功能，在删除列表中的元素时，python会自动对列表内存进行收缩，并移动列表中的元素以保证元素之间没有间隙**
，所以使用“循环+remove（）方法”来删除列表中某一重复元素时，如果存在相邻的该元素，在删除前面一个元素后，后一个元素会被移动到刚被删除的这个元素的位置，这样这个元素就“躲过了删除”

![](https://img.jbzj.com/file_images/article/202101/202114103451588.png?202104103457)

对于以上问题代码可以做如下修改：

```python

    x=[1,2,1,2,1,2,1,2]
    y=[1,1,2,1,2,1,2,1,1,1,2]
    for i in x:
     if i==1:
      x.remove(i)
    print("List_1=",x)
    while y.count(1)>0://或者while 1 in y:
     for i in y:
      if i==1:
       y.remove(i)
    print("List_2=",y)
    
```

输出结果：

> List_1= [2, 2, 2, 2]  
>  
>  List_2= [2, 2, 2, 2]

**总结**

到此这篇关于Python列表元素删除和remove()方法详解的文章就介绍到这了,更多相关Python列表元素删除和remove()方法内容请搜索脚本之家以前的文章或继续浏览下面的相关文章希望大家以后多多支持脚本之家！

